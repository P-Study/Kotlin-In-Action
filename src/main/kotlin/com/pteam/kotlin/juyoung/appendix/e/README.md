# 코루틴과 Async/Await

## 코루틴이란?

* 서로 협력해서 실행을 주고받으면서 작동하는 여러 서브루틴
* 이전에 자신의 실행이 마지막으로 중단됐던 지점의 다음 장소에서 실행을 재개
* 서브루틴은 진입점과 반환점이 단 하나밖에 없어 메인 루틴에 종속적이지만, 코루틴은 진입 지점이 여러개라서 메인 루틴에 종속적이지 않고 대등하게 데이터를 주고 받을 수 있음(메인스레드를 블락하지 않음)

## 여러가지 코루틴

* 코루틴 빌더: 코루틴을 실행할 때 사용하는 여러가지 함수
    * `launch` 코루틴을 job으로 반환하며, 만들어진 코루틴은 기본적으로 즉시 실행됨. 동시성 작업이 결과를 만들어내지 않는 경우에 적합
    * `runBlocking` 내부 코루틴이 모두 끝난 후 반환
    * `delay` 설정한 시간이 지날 때까지 다른 코루틴에게 실행을 양보

* `async` 사실상 launch와 같은 일을 함. 유일한 차이는 launch가 job을 반한하는 반면 async는 Deffered를 반환한다는 점
    * launch는 Job을 반환하며 이를 통해 상태 관리를 할 수 있음
    * async는 Deffered를 반환하며 이를 통해 상태 관리와 결과값에 접근할 수 있음
    * Deffered는 Job을 상속한 클래스로 launch 대신 async를 사용해도 항상 아무 문제가 없음
        * Job은 아무 타입 파라미터가 없는데 Deffered는 타입 파라미터가 있는 제네릭
        * Deffered 안에는 await() 함수가 정의돼 있음

## 코루틴 컨텍스트와 디스패처

* `CoroutineContext` 실제로 코루틴이 실행 중인 여러 작업(Job 타입)과 디스패처를 저장하는 일종의 맵
    * 코틀린 런타임은 코루틴 컨텍스트를 사용해 다음에 실행할 작업을 선정하고, 어떻게 스레드에 배정할지에 대한 방법을 결정
    * 같은 launch를 사용하더라도 전달하는 컨텍스트에 따라 서로 다른 스레드상에서 코루틴이 실행됨

## 코루틴 빌더와 일시 중단 함수

* 코루틴 빌더
    * launch, async, runBlocking
    * `produce` 정해진 채널로 데이터를 스트림으로 보내는 코루틴을 만들고, ReceiveChannel<>을 반환
    * `actor` 정해진 채널로 메시지를 받아 처리하는 액터를 코루틴으로 만들고, SendChannel<> 채널의 send() 메서드를 통해 액터에게 메시지를 보낼 수 있음

* 일시 중단 함수
    * delay, yield
    * `withContext` 다른 컨텍스트로 코루틴을 전환
    * `withTimeout` 코루틴이 정해진 시간 안에 실행되지 않으면 예외를 발생시키게 함
    * `withTimeoutOrNull` 코루틴이 정해진 시간 안에 실행되지 않으면 null을 결과로 반환
    * `awaitAll` 모든 작업의 성공을 기다림. 작업 중 어느 하나가 예외로 실패하면 awaitAll도 그 예외로 실패
    * `joinAll` 모든 작업이 끝날 떄까지 현재 작업을 일시 중단시킴

## suspend 키워드와 코틀린의 일시 중단 함수 컴파일 방법

* 일시 중단 함수를 코루틴이나 일시 중단 함수가 아닌 함수에서 호출하는 것은 컴파일러 수준에서 금지됨
* fun 앞에 suspend를 넣으면 일시 중단 함수를 만들 수 있음
* suspend 함수 작동 원리: 일시 중단 함수 안에서 yield()를 해야 하는 경우
    * 아래 두 가지 작업을 하기 위해 CPS(continuation passing style) 변환과 상태 기계를 활용해 코드를 생성
        * 코루틴에 진입할 때와 코루틴에서 나갈 때 코루틴이 실행 중이던 상태를 저장하고 복구하는 등의 작업을 할 수 있어야 함
        * 현재 실행 중이던 위치를 저장하고 다시 코루틴이 재개될 때 해당 위치부터 실행을 재개할 수 있어야 함
    * 코루틴 컨텍스트에 있는 디스패처에 의해 수행됨
        * 다음에 어떤 코루틴을 실행할지 결정
* CPS 변환은 프로그램의 실행 중 특정 시점 이후에 진행해야 하는 내용을 별도의 함수로 뽑고, 그 함수에게 현재 시점까지 실행한 결과를 넘겨서 처리하게 만드는 소스코드 변환 기술
    * 프로그램이 다음에 해야 할 일이 항상 컨티뉴에이션이라는 함수 형태로 전달되어 나중에 할 일과 컨티뉴에이션에 넘겨야 할 값이 무엇인지 명확히 알 수 있ㅊ
    * CPS를 사용하면 코루틴을 만들기 위해 필수적인 일시중단 함수를 만드는 문제가 쉽게 해결됨
    * 다만 모든 코드를 전부 CPS로만 변환하면 지나치게 많은 중간 함수들이 생길 수 있으므로, 상태 기계를 적당히 사용해서 코루틴이 제어를 다른 함수에 넘겨야 하는 시점에만 컨티뉴에이션이 생기도록 만들 수
      있음
