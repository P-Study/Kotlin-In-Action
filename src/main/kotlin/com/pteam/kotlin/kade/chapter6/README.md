# 6. 코틀린 타입 시스템
- 타입 시스템은 코틀린에서 가장 중요한 부분
- 코드의 가독성을 향상시키기 위해 <strong>널이 될 수 있는 타입</strong>과 <strong>읽기 전용 컬렉션</strong>을 제공한다

## 6.1 널 가능성
- 널 가능성은 NPE를 피할 수 있게 돕기 위한 타입 시스템의 특성
- Kotlin등 다양한 언어에서 null에 대한 접근 방법을 실행 시점에서 컴파일 시점으로 옮기도록 함
  - 널 가능성에 대한 내용을 읽지 않고 본 나의 생각은 
    - Before Read Book 왜 널 가능성을 두었을까 였는데 
    - After Read Book 읽고 난 후 널 가능성을 가지는 타입의 특성은 값에 대해 정확하게 이해하고 사용하라는 의미로 이해함

### 6.1.1 널이 될 수 있는 타입
- 변수가 널이 될 수 있다면 해당 변수에 대해 메소드를 호출하면 NPE가 발생할 수 있으므로 안전하지 않음

#### 자바 예제 1
- 이 함수는 안전한가라는 물음을 던졌다
- String은 Wrapper Class로 null을 가질 수 있다. 때문에 s.length() 호출 시 s가 null이라면 해당 메소드는 null로 부터 안전하지 않다
```java
public class NullableType {

  int strLen(String s) {
    return s.length();
  }
}
```

#### 코틀린 예제 1
- 코틀린에서도 자바와 동일하게 메소드를 작성했다.
- 동일하게 "이 함수가 널을 인자로 받을 수 있는가?"에 대한 물을을 던졌다.
- 아래 코드에서도 null 처리를 하지 않았기 때문에 s가 null을 입력받게 되면 NPE가 발생하게 된다.
```kotlin
class NullableType {

  fun strLen(s: String) = s.length
}
```

- 코틀린에서는 인자에 null과 값을 받을 수 있도록 <strong>?</strong> 키워드를 사용했다.
- 어떤 타입이든 타입 뒤에 <strong>?</strong>를 붙이면 null을 저장할 수 있다.
------------

```
Type? = Type 또는 null
```
- <strong>?</strong> 키워드를 통해 null 타입을 다룰 수 있다.
- 하지만, null을 받을 수 있는 변수는 아래와 같은 여러 제약이 있고 실질적으로 null과 비교하기 위해 사용된다.
- compiler는 null과 비교한 사실을 기억하고 null이 아님이 확실한 영역에서는 해당 값을 null이 될 수 없는 타입의 값처럼 사용할 수 있다.
#### 제약 1
- null을 받을 수 있는 변수는 변수.메소드()를 호출할 수 없다.
```kotlin
fun strLenSafe(s: String?) = s.length
```

#### 제약 2
- null이 될 수 없는 값을 null이 될 수 없는 타입의 변수에 대입할 수 없다.
```kotlin
fun secondNullableConstraints() {
    val x: String? = null
    val y: String = x       // compile error
}
```

#### 제약 3
- null이 될 수 있는 타입의 값을 null이 될 수 없는 타입의 파라미터를 받는 함수에 전달 할 수 없다.
```kotlin
fun thirdNullableConstraints() {
  val x:String? = null
  strLen(x)
}
```

### 6.1.2 타입의 의미
- null이 될 수 있는 타입과 null이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 이해할 수 있다.
- 또한, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.
- 즉, 비즈니스 로직에 대한 이해를 통해 타입을 명확히 지정하고 실행 시점에 예외 발생을 막아야 한다.
- <strong> 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다. 모든 검사는 컴파일 시점에 수행되며 별도의 실행 시점 부가 비용이 들지 않는다. -> null 가능성 타입을 이용해 컴파일 검사를 적극 이용하라는 의미인 것 같다. </strong>

### 6.1.3 안전한 호출 연산자: ?.
- 안전한 호출 연산자 ?. 은 가장 유용한 도구 -> 좋으니까 많이 써라...
- null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
- 호출하려는 값이 null이 아니라면 ?.은 메소드 호출처럼 작동하고, 호출하려는 값이 null이라면 호출은 무시되고 null이 반환된다.
- 반환 값이 null이라는 것에 유의해라.

- 코틀린에서 if else를 식으로 표현한 이유에 대한 생각 -> null에 대한 처리를 간결하게 이용하기 위함이었지 않았을까? 

### 6.1.4 엘비스 연산자: ?:
- null 대신 사용할 default value를 지정하여 편리하게 사용할 수 있는 연산자이다.
  - ?: 모양이 엘비스 프레슬리의 헤어스타일과 눈과 닮아 이름을 명명했다고 한다. -> kotlin 설계자들은 재밌게 설계를 했다는게 느껴지는 것 같다

### 6.1.5 안전한 캐스트: as?
- as?는 값을 대상 타입으로 변환할 수 없으면 null 반환

### 6.1.6 널 아님 단언: !!
- null이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다.
- assertion이라는 단어가 되게 매력적이라는 생각과 개발자에게 해당 키워드를 씀으로써 주의를 해라라는 안내인 것 같다.
- 예외는 null값을 사용하는 코드가 아니라 단언문이 위치한 곳을 가리킨다는 점에 유의해라. -> 예외를 호출할 때 발생시키지 않아 더욱 명확한 위치를 명확하게 알려준다.
- 키워드를 씀으로써 오류 문구에 대한 생각도 하게 한다 p258 중간 참고

### 6.1.7 let 함수
- let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 처리할 수 있다.

### 6.1.8 나중에 초기화할 프로퍼티
- 초기화하지 않고 널이 도리 수 없는 프로퍼티를 선언한다. -> null을 허용하지 않음으로써 안정성을 올렸다.
- 예외 처리 p263 맨 위

### 6.1.9 널이 될 수 있는 타입 확장
- 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.
- 예제 필수
- 널이 될 수 있는 타입에 대한 확장을 정의하면 널이 될 수 있는 값에 대해 그 확장함수를 호출할 수 있다.

### 6.1.10 타입 파라미터의 널 가능성
- 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.
- 널이 될 수 없는 상한을 사용할 수 있다. 

### 6.1.11 널 가능성과 자바
- 다시 읽기